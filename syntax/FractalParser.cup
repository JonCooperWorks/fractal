import java_cup.runtime.*;
import java.io.*;
import java.util.*;

/* Preliminaries to set up and use the scanner.  */
parser code {:
		Lexer lexer;

		public FractalParser(Lexer l) {
		    // As of CUP v0.11, need to pass Lexer to superclass
		    super(l);
		    lexer = l;
		}

		public void report_error(String message, Object info) {
		    System.err.println(message);
		}

		public void syntax_error(Symbol cur_token) {
		    System.err.print("Line " + lexer.getLine() +
				     " near char " + lexer.getChar() + ": ");
		    report_error("Syntax error", cur_token);
		    System.err.println ("Last token read is " +
					 lexer.getText());
		}
:};

init with {::};

scan with {:
		try {
		    return lexer.next_token();
		} catch (java.io.IOException ioe) {
		    System.out.println ("Unrecognised token");
		    System.out.println(ioe.getMessage());
		    throw ioe;
		}
:};

/* Terminals (tokens returned by the scanner). */

// keywords
terminal FORWARD, BACK, RIGHT, HOME, CLEAR, FRACTAL, END, SELF, RENDER, LEVEL,
         SCALE, DEF, SAVE, RESTORE;

// special symbols
terminal LPAREN, RPAREN, COMMA, LBRACE, RBRACE;

// arithmetic operators
terminal PLUS, MINUS, MUL, DIV, MOD, ASSIGN;

// fractal operators
terminal COMPOSE, SEQUENCE;

// boolean operators
terminal LT, GT, EQ, NOT, AND, OR;

// terminals with values
terminal Integer INTEGER;
terminal Double DOUBLE;
terminal String VARIABLE;

/* Non terminals */
nonterminal ASTProgram program;
nonterminal ASTStmtSequence stmtList;
nonterminal ASTStatement stmt;
nonterminal ASTDefine definition;
nonterminal ArrayList<ASTExp> expList;
nonterminal ASTExp expression;
nonterminal ASTExp term;
nonterminal ASTExp factor;

program ::= stmtList:s {: RESULT = new ASTProgram(s); :};

stmtList ::= stmtList:lst stmt:s {:
		lst.add(s); 
		RESULT = lst;
		:} |
	     stmt:s {:
		RESULT = new ASTStmtSequence(s);
		:};

stmt ::= definition:d {: RESULT = d; :} |
	 expression:e {: RESULT = new ASTStatement(e); :};

definition ::= VARIABLE:v ASSIGN expression:e {:
		   RESULT = new ASTStmtDefinition(v, e);
		:};

expList ::= expList:lst COMMA expression:e {:
	        lst.add(e);
	    	RESULT = lst;
	    :}|
	    expression:e {:
	        ArrayList<ASTExp> lst = new ArrayList<ASTExp>();
		lst.add(e);
	    	RESULT = lst;
	    :};

expression ::= 	expression:e PLUS term:t {:
			RESULT = new ASTExpAdd(e, t); :} |
		expression:e MINUS term:t {:
			RESULT = new ASTExpSub(e, t); :} |
		term:t {: RESULT = t; :};

term ::= term:t MUL factor:f {:
		RESULT = new ASTExpMul(t, f); :} |
	 term:t DIV factor:f {:
		RESULT = new ASTExpDiv(t, f); :}; 

factor ::= INTEGER:ilit {: RESULT = new ASTExpLit(ilit); :} |
	   VARIABLE:var {: RESULT = new ASTExpVar(var); :} |
	   LPAREN expression:e RPAREN {: RESULT = e; :};
